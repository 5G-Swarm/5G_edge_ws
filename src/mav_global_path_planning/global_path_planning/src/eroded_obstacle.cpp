#include <functional>
#include <mutex>
#include <thread>
#include <string>
#include <tf/tf.h>
#include <tf/transform_listener.h>
#include <map_msgs/OccupancyGridUpdate.h>
#include <nav_msgs/OccupancyGrid.h>
#include <nav_msgs/Odometry.h>
#include <nav_msgs/Path.h>
// #include "bspline.cpp"
#include <queue>
#include <unordered_map>
// #include <boost>
#include <time.h>
#include "KDTree/KDTree.hpp"
#include <typeinfo>

#define INF INT_MAX
using namespace std;

//目前的问题：可以跑bag，当时无法找到最近的目标点，kdtree有问题
namespace frontier_detection
{

    struct Node{
    float cost;
    int index;
    bool operator<(const Node &a) const {
        return cost < a.cost;
    }
    };
    class frontierdetection
    {
        public:
            frontierdetection(ros::NodeHandle private_nh)
            {
                static_path={7566424, 7582418, 7594420, 7606422, 7634400, 7654390, 7702338, 7750286, 7822198, };//path for map generated by rtk
                getCostmap = false;
                NODE = private_nh;
                costmap_sub_global_ = private_nh.subscribe<nav_msgs::OccupancyGrid>("/map_pub_cyclic", 1, &frontierdetection::CostmapSubCallback_global, this);
                // position_sub_global_ = private_nh.subscribe<nav_msgs::Odometry>("/base2map", 1, &frontierdetection::position_callback, this);
                costmap_with_path_ = private_nh.advertise<nav_msgs::OccupancyGrid>("/costmap_with_path", 1);
                // global_path_pub_=private_nh.advertise<nav_msgs::Path>("/global_path_planning", 1);
            }


        private:
            
            point_t get_kdtree_index(point_t point, KDTree tree)
            {
                point_t point_temp;
                point_temp.push_back(point[0]);
                point_temp.push_back(point[1]);
                point_t closest_point = tree.nearest_point(point_temp);
                return closest_point;
            }
            void indextocell(int index, int &x, int &y)
            {
                x = index % global_costmap.info.width;
                y = index / global_costmap.info.width;
            }
            void maptoworld(int x, int y, double &wx, double &wy)
            {
                // wx = origin_x_ + (x + 0.5) * resolution_;
                // wy = origin_y_ + (y + 0.5) * resolution_;
                int u=x, v=global_costmap.info.height-y-1;
                wx = (741-v)/20;
                wy = (1165-u)/20;
            }
            bool isInBounds(int x, int y)
            {
                if( x < 0 || y < 0 || x >= global_costmap.info.height || y >= global_costmap.info.width)
                    return false;
                return true;
            }
            vector<int> get_neighbors(int current_cell)
            {   
                vector<int> neighborIndexes;
                
                for (int i = -1; i <= 1; i++)
                {
                    for (int j = -1; j <= 1; j++)
                    {
                        unsigned tmp1, tmp2;
                        // costmap_->indexToCells(current_cell, tmp1, tmp2);
                        tmp1 = current_cell%global_costmap.info.width;
                        tmp2 = current_cell/global_costmap.info.width;
                        int nextX = tmp1 + i;
                        int nextY = tmp2 + j;
                        // int nextIndex = costmap_->getIndex(nextX, nextY);
                        int nextIndex = nextX+nextY*global_costmap.info.width;

                        if(!( i == 0 && j == 0) && isInBounds(nextX, nextY) && OGM[nextIndex])
                        {
                            neighborIndexes.push_back(nextIndex);
                        }
                    }
                }
                return neighborIndexes;
            }
            double getMoveCost(int firstIndex, int secondIndex)
            {
                unsigned int tmp1, tmp2;
                // costmap_->indexToCells(firstIndex, tmp1, tmp2);
                tmp1 = firstIndex%global_costmap.info.width;
                tmp2 = firstIndex/global_costmap.info.width;
                int firstXCord = tmp1,firstYCord = tmp2;
                // costmap_->indexToCells(secondIndex, tmp1, tmp2);
                tmp1 = secondIndex%global_costmap.info.width;
                tmp2 = secondIndex/global_costmap.info.width;
                int secondXCord = tmp1, secondYCord = tmp2;
                
                int difference = abs(firstXCord - secondXCord) + abs(firstYCord - secondYCord);
                // Error checking
                if(difference != 1 && difference != 2){
                    ROS_ERROR("Astar global planner: Error in getMoveCost - difference not valid");
                    return 1.0;
                }
                if(difference == 1)
                    return 1.0;
                else
                    return 1.4;
            }
            double getHeuristic(int cell_index, int goal_index)
            {
                unsigned int tmp1, tmp2;
                tmp1 = cell_index%global_costmap.info.width;
                tmp2 = cell_index/global_costmap.info.width;
                int startX = tmp1, startY = tmp2;
                tmp1 = goal_index%global_costmap.info.width;
                tmp2 = goal_index/global_costmap.info.width;
                int goalX = tmp1, goalY = tmp2;
                
                return abs(goalY - startY) + abs(goalX - startX);
            }

            bool path_planning(int start_index, int goal_index, nav_msgs::OccupancyGrid global_costmap, std::vector<int>& plan_result)
            {
                
                int map_size = global_costmap.data.size();
                vector<float> gCosts(map_size, INF);
                vector<int> cameFrom(map_size, -1);
                
                multiset<Node> priority_costs;
                
                gCosts[start_index] = 0;
                
                Node currentNode;
                currentNode.index = start_index;
                currentNode.cost = gCosts[start_index] + 0;
                priority_costs.insert(currentNode);
                vector<geometry_msgs::PoseStamped> plan;
                vector<geometry_msgs::PoseStamped> replan;
                
                plan.clear();
                replan.clear();
                std::cout<<"begin planning"<<std::endl;
                
                while(!priority_costs.empty())
                {
                    // Take the element from the top
                    currentNode = *priority_costs.begin();
                    //Delete the element from the top
                    priority_costs.erase(priority_costs.begin());
                    if (currentNode.index == goal_index){
                        break;
                    }
                    // Get neighbors
                    vector<int> neighborIndexes = get_neighbors(currentNode.index);
                    
                    for(int i = 0; i < neighborIndexes.size(); i++){
                        if(cameFrom[neighborIndexes[i]] == -1){
                        gCosts[neighborIndexes[i]] = gCosts[currentNode.index] + getMoveCost(currentNode.index, neighborIndexes[i]);
                        Node nextNode;
                        nextNode.index = neighborIndexes[i];
                        //nextNode.cost = gCosts[neighborIndexes[i]];    //Dijkstra Algorithm
                        nextNode.cost = gCosts[neighborIndexes[i]] + getHeuristic(neighborIndexes[i], goal_index);    //A* Algorithm
                        cameFrom[neighborIndexes[i]] = currentNode.index;
                        priority_costs.insert(nextNode);
                        }
                    }
                }
                
                if(cameFrom[goal_index] == -1){
                    cout << "Goal not reachable, failed making a global path." << endl;
                    return false;
                }
                
                if(start_index == goal_index)
                    return false;
                //Finding the best path
                vector<int> bestPath;
                currentNode.index = goal_index;
                while(currentNode.index != start_index){
                    bestPath.push_back(cameFrom[currentNode.index]);
                    currentNode.index = cameFrom[currentNode.index];
                }
                reverse(bestPath.begin(), bestPath.end());
                // std::cout<<*bestPath.begin()<<std::endl;
                for(auto i:bestPath)
                    std::cout<<i<<",";

                std::cout<<"before: "<<Path.size()<<std::endl;
                Path.clear();
                int path;
                for(int i = 0; i < bestPath.size(); i=i+3){
                    path = bestPath[i];
                    Path.push_back(path);
                }
                std::cout<<"after: "<<Path.size()<<std::endl;
                cout << "/***********/" << "bestPath.size():" << bestPath.size() << "*****" <<"Path.size():" << Path.size() << endl;
               
            }
            void position_callback(const nav_msgs::Odometry::ConstPtr& msg)
            {
                nav_msgs::Odometry position=*msg;
                double robot_position_x = position.pose.pose.position.x;
                double robot_position_y = position.pose.pose.position.y;
                robot_index_y = 2949-20*robot_position_x;//bag2
                robot_index_x = 2089-20*robot_position_y;
                robot_index_y = global_costmap.info.height-robot_index_y-1;

                robot_index = robot_index_y*global_costmap.info.width+robot_index_x;
                point_t robot_position = {(double)robot_index_x, (double)robot_index_y};
                
                point_t local_point;
                pointVec local_point_vec;
                for(int i=0;i<static_path.size();i++)
                {
                    // std::cout<<"static_path[i]:"<<static_path[i]<<std::endl;
                    // local_point={static_path[i]/global_costmap.info.width,static_path[i]%global_costmap.info.width};
                    double y=static_path[i]/(global_costmap.info.width);
                    double x=static_path[i]%(global_costmap.info.width);
                    local_point={x,y};
                    // std::cout<<"local_point:"<<y*global_costmap.info.width+x<<std::endl;
                    local_point_vec.push_back(local_point);
                }
                KDTree local_path_kdtree(local_point_vec);

                robot_in_path_position = get_kdtree_index(robot_position,local_path_kdtree);
                
                for(int i=0;i<static_path.size();i++)
                {
                    if(robot_in_path_position[0]+robot_in_path_position[1]*global_costmap.info.width-static_path[i]<1&&robot_in_path_position[0]+robot_in_path_position[1]*global_costmap.info.width-static_path[i]>=0)
                    {
                        std::cout<<"result1:"<<robot_in_path_position[0]+robot_in_path_position[1]*global_costmap.info.width-static_path[i]<<std::endl;
                        path_index=i;
                        // std::cout<<"path_index:"<<path_index<<std::endl;
                        break;
                    }
                        
                    }
                
                // std::cout<<"robot_closest_position:"<<robot_position[0]<<" "<<robot_position[1]<<endl;
                nav_msgs::Path Path_published;
                geometry_msgs::PoseStamped this_pose_stamped;
                for(int i = path_index; i < path_index+200; i=i+10){
                    int temp_path_id = static_path[i];
                    Path.push_back(temp_path_id);
                    this_pose_stamped.pose.position.x = temp_path_id%global_costmap.info.width;
                    this_pose_stamped.pose.position.y = global_costmap.info.height-temp_path_id/global_costmap.info.width-1;
                    Path_published.header=global_costmap.header;
                    Path_published.poses.push_back(this_pose_stamped);
                    
                }
                global_path_pub_.publish(Path_published);
            }
            //renew
            double calculte_distance(int x, int y)
            {
                
                double distance = sqrt(pow(x/(int)global_costmap.info.width-y/(int)global_costmap.info.width,2)+pow(x%(int)global_costmap.info.width-y%(int)global_costmap.info.width,2));
                return distance;
            }
            void CostmapSubCallback_global(const nav_msgs::OccupancyGrid::ConstPtr& map)
            {
                
                ros::Time timestamp = map->header.stamp;
                global_costmap = *map;
                for(int i=0;i<global_costmap.data.size();i++)
                {
                    if(global_costmap.data[i]==100)
                    {
                        obstacle_id.push_back(i);
                    }
                }
                int a[4]={-1,1,(int)global_costmap.info.width,-(int)global_costmap.info.width};
                bool exit=0;
                queue<int> obstacle;
                std::unordered_map<int, int> visited;
                for(auto i:obstacle_id)
                {
                    obstacle.push(i);
                    int current_obstacle_id=i;
                    while(!obstacle.empty())
                    {
                        int temp_id=obstacle.front();
                        visited[temp_id]=1;
                        obstacle.pop();
                            for(int j=0;j<4;j++)
                            {
                                int temp_id_new=temp_id+a[j];
                                if(temp_id_new>=0&&temp_id_new<global_costmap.data.size()&&calculte_distance(temp_id_new,current_obstacle_id)<=obstacle_radius&&!visited[temp_id_new])
                                {
                                    visited[temp_id_new]++;
                                    obstacle.push(temp_id_new);
                                    global_costmap.data[temp_id_new]=100;
                                }
                            }
                    }
                }

                costmap_with_path_.publish(global_costmap);

                // OGM.resize(global_costmap.data.size());
                // for(int i=0;i<global_costmap.data.size();i++)
                // {
                //     if(global_costmap.data[i]==0)
                //         OGM[i]=true;
                //     else
                //         OGM[i]=false;
                // }
                
                // int robot_closest_index=0;
                // if(robot_in_path_position.size()==2)
                //     robot_closest_index = robot_in_path_position[1]*global_costmap.info.width+robot_in_path_position[0];


                // for(int i=0;i<100;i++)
                // {
                //     global_costmap.data[i+robot_closest_index]=100;
                // }
                // for(int i=0;i<100;i++)
                // {
                //     global_costmap.data[i+robot_index]=100;
                // }
                
                // // for(auto i:static_path)
                // //     global_costmap.data[i]=100;
                // // if(path_index==0)
                // {
                //     for(int i=path_index; i<path_index+200; i+=10)
                //     {
                //         global_costmap.data[static_path[i]]=100;
                //     }
                // }
                // costmap_with_path_.publish(global_costmap);

            }


            
            void GetRobotpose(std::string iden_frame_id,geometry_msgs::PoseStamped& global_local_pose, ros::Time timestamp)
            {
            tf::StampedTransform transform;
            geometry_msgs::PoseStamped iden_pose;
            iden_pose.header.frame_id = iden_frame_id;
            iden_pose.header.stamp = ros::Time::now(); 
            iden_pose.pose.orientation.w = 1;
            tf_listener_.waitForTransform("/robot0/map",iden_frame_id, ros::Time(0), ros::Duration(2.0));
            tf_listener_.lookupTransform( "/robot0/map",iden_frame_id, ros::Time(0), transform);
            global_local_pose.pose.position.x=transform.getOrigin().x();
            global_local_pose.pose.position.y=transform.getOrigin().y();
            global_local_pose.pose.position.z=transform.getOrigin().z();
            }

            bool getCostmap;
            ros::NodeHandle NODE;
            ros::Subscriber costmap_sub_global_;
            ros::Subscriber goal_sub_global_;
            ros::Subscriber position_sub_global_;
            ros::Publisher costmap_with_path_;
            ros::Publisher global_path_pub_;
            nav_msgs::OccupancyGrid global_costmap;
            nav_msgs::OccupancyGrid local_costmap;
            geometry_msgs::PoseStamped global_local_pose;
            geometry_msgs::PoseStamped global_goal_pose;
            geometry_msgs::PoseStamped closest_frontier_point;
            std::vector<bool> OGM;//check whether the cell is known
            vector<int> obstacle_id;
            vector<int> Path;
            vector<int> Path_smooth;
            vector<int> static_path;
            int robot_index_x=0;
            int robot_index_y=0;
            point_t robot_in_path_position;
            int path_index=0;

            std::mutex lock_costmap;
            std::thread tf_thread_;
            tf::TransformListener tf_listener_;
            int  robot_index=0;
            int goal_index;
            int temp_goal_index;
            double obstacle_radius=5;


            // protected:
    };
}
int main(int argc, char** argv)
{
    ros::init(argc, argv, "frontier_detection");
    ros::NodeHandle private_nh1("~");
    frontier_detection::frontierdetection ta(private_nh1);
    ros::MultiThreadedSpinner spinner;
    spinner.spin();
    return 0;
}